<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Kubernetes源码阅读—kube-scheduler(一) · Arthur</title><meta name="description" content="Kubernetes源码阅读—kube-scheduler(一) - Bin Xu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://xizie.com/atom.xml" title="Arthur"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/xubinlife" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Kubernetes源码阅读—kube-scheduler(一)</h1><div class="post-info">Feb 26, 2019</div><div class="post-content"><p>kube-scheduler依赖于cobra包构建命令行支持，该包是支持通用的命令行构建库。</p>
<h2 id="func-main"><a href="#func-main" class="headerlink" title="func main()"></a><code>func main()</code></h2><p><a href="https://github.com/kubernetes/kubernetes/blob/v1.11.7/cmd/kube-scheduler/scheduler.go#L34" target="_blank" rel="noopener"><code>kubernetes/cmd/kube-scheduler/scheduler.go</code></a><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UTC().UnixNano())</span><br><span class="line"></span><br><span class="line">    command := app.NewSchedulerCommand()   <span class="comment">// 创建Cobra格式的Scheduler Command</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> once we switch everything over to Cobra commands, we can go back to calling</span></span><br><span class="line">    <span class="comment">// utilflag.InitFlags() (by removing its pflag.Parse() call). For now, we have to set the</span></span><br><span class="line">    <span class="comment">// normalize func and add the go flag set by hand.</span></span><br><span class="line">    pflag.CommandLine.SetNormalizeFunc(utilflag.WordSepNormalizeFunc) <span class="comment">// 将配置中的_转换为-</span></span><br><span class="line">    pflag.CommandLine.AddGoFlagSet(goflag.CommandLine)</span><br><span class="line">    <span class="comment">// utilflag.InitFlags()</span></span><br><span class="line">    logs.InitLogs()</span><br><span class="line">    <span class="keyword">defer</span> logs.FlushLogs()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := command.Execute(); err != <span class="literal">nil</span> &#123;   <span class="comment">// 执行命令</span></span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">"%v\n"</span>, err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，<code>NewSchedulerCommand()</code>向cobra注册了scheduler的命令。</p>
<h2 id="func-NewSchedulerCommand"><a href="#func-NewSchedulerCommand" class="headerlink" title="func NewSchedulerCommand()"></a><code>func NewSchedulerCommand()</code></h2><p><a href="https://github.com/kubernetes/kubernetes/blob/v1.11.7/cmd/kube-scheduler/app/server.go#L67" target="_blank" rel="noopener"><code>kubernetes/cmd/kube-scheduler/app/server.go</code></a><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewSchedulerCommand creates a *cobra.Command object with default parameters</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSchedulerCommand</span><span class="params">()</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line">    opts, err := options.NewOptions()   <span class="comment">// 新建储存scheduler的配置的options</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Fatalf(<span class="string">"unable to initialize command options: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cmd := &amp;cobra.Command&#123;  <span class="comment">// 定义Scheduler的Command</span></span><br><span class="line">        Use: <span class="string">"kube-scheduler"</span>,</span><br><span class="line">        Long: <span class="string">`The Kubernetes scheduler is a policy-rich, topology-aware,</span></span><br><span class="line"><span class="string">workload-specific function that significantly impacts availability, performance,</span></span><br><span class="line"><span class="string">and capacity. The scheduler needs to take into account individual and collective</span></span><br><span class="line"><span class="string">resource requirements, quality of service requirements, hardware/software/policy</span></span><br><span class="line"><span class="string">constraints, affinity and anti-affinity specifications, data locality, inter-workload</span></span><br><span class="line"><span class="string">interference, deadlines, and so on. Workload-specific requirements will be exposed</span></span><br><span class="line"><span class="string">through the API as necessary.`</span>,</span><br><span class="line">        Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">            verflag.PrintAndExitIfRequested()</span><br><span class="line">            utilflag.PrintFlags(cmd.Flags())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">0</span> &#123;</span><br><span class="line">                fmt.Fprint(os.Stderr, <span class="string">"arguments are not supported\n"</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> errs := opts.Validate(); <span class="built_in">len</span>(errs) &gt; <span class="number">0</span> &#123;     <span class="comment">// 检查配置参数</span></span><br><span class="line">                fmt.Fprintf(os.Stderr, <span class="string">"%v\n"</span>, utilerrors.NewAggregate(errs))</span><br><span class="line">                os.Exit(<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(opts.WriteConfigTo) &gt; <span class="number">0</span> &#123;    <span class="comment">// 检查是否有writeconfigto参数，如有则将Component配置写入文件</span></span><br><span class="line">                <span class="keyword">if</span> err := options.WriteConfigFile(opts.WriteConfigTo, &amp;opts.ComponentConfig); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    fmt.Fprintf(os.Stderr, <span class="string">"%v\n"</span>, err)</span><br><span class="line">                    os.Exit(<span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                glog.Infof(<span class="string">"Wrote configuration to: %s\n"</span>, opts.WriteConfigTo)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            c, err := opts.Config()     <span class="comment">// 根据options生成config结构体</span></span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Fprintf(os.Stderr, <span class="string">"%v\n"</span>, err)</span><br><span class="line">                os.Exit(<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">            <span class="keyword">if</span> err := Run(c.Complete(), stopCh); err != <span class="literal">nil</span> &#123;   <span class="comment">// 具体执行函数</span></span><br><span class="line">                fmt.Fprintf(os.Stderr, <span class="string">"%v\n"</span>, err)</span><br><span class="line">                os.Exit(<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    opts.AddFlags(cmd.Flags())  <span class="comment">// 添加Scheduler的配置参数</span></span><br><span class="line">    cmd.MarkFlagFilename(<span class="string">"config"</span>, <span class="string">"yaml"</span>, <span class="string">"yml"</span>, <span class="string">"json"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="func-Run-c-schedulerserverconfig-CompletedConfig-stopCh-lt-chan-struct"><a href="#func-Run-c-schedulerserverconfig-CompletedConfig-stopCh-lt-chan-struct" class="headerlink" title="func Run(c schedulerserverconfig.CompletedConfig, stopCh &lt;-chan struct{})"></a><code>func Run(c schedulerserverconfig.CompletedConfig, stopCh &lt;-chan struct{})</code></h2><p><a href="https://github.com/kubernetes/kubernetes/blob/v1.11.7/cmd/kube-scheduler/app/server.go#L124" target="_blank" rel="noopener"><code>kubernetes/cmd/kube-scheduler/app/server.go</code></a><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(c schedulerserverconfig.CompletedConfig, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// To help debugging, immediately log version</span></span><br><span class="line">    glog.Infof(<span class="string">"Version: %+v"</span>, version.Get())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply algorithms based on feature gates.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> make configurable?</span></span><br><span class="line">    <span class="comment">// 检查featureGate的设置</span></span><br><span class="line">    <span class="comment">// - 如果TaintNodesByCondition参数enable了，删除预选策略"CheckNodeCondition",</span></span><br><span class="line">    <span class="comment">// "CheckNodeMemoryPressure", "CheckNodePIDPressurePred", "CheckNodeDiskPressure",</span></span><br><span class="line">    <span class="comment">// 注册 PodToleratesNodeTaints &amp; CheckNodeUnschedulable两个预选策略</span></span><br><span class="line">    <span class="comment">// - 如果ResourceLimitsPriorityFunction参数enable了，注册ResourceLimitsPriorityMap优选策略</span></span><br><span class="line">    algorithmprovider.ApplyFeatureGates()  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configz registration.</span></span><br><span class="line">    <span class="keyword">if</span> cz, err := configz.New(<span class="string">"componentconfig"</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">        cz.Set(c.ComponentConfig)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"unable to register configz: %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build a scheduler config from the provided algorithm source.</span></span><br><span class="line">    schedulerConfig, err := NewSchedulerConfig(c)   <span class="comment">// 生成scheduler的配置</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the scheduler.</span></span><br><span class="line">    sched := scheduler.NewFromConfig(schedulerConfig)   <span class="comment">// 根据配置生成scheduler</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare the event broadcaster.</span></span><br><span class="line">    <span class="keyword">if</span> c.Broadcaster != <span class="literal">nil</span> &amp;&amp; c.EventClient != <span class="literal">nil</span> &#123;   <span class="comment">// 准备事件广播</span></span><br><span class="line">        c.Broadcaster.StartRecordingToSink(&amp;v1core.EventSinkImpl&#123;Interface: c.EventClient.Events(<span class="string">""</span>)&#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start up the healthz server. 启动healthz和metrics</span></span><br><span class="line">    <span class="keyword">if</span> c.InsecureServing != <span class="literal">nil</span> &#123;</span><br><span class="line">        separateMetrics := c.InsecureMetricsServing != <span class="literal">nil</span></span><br><span class="line">        handler := buildHandlerChain(newHealthzHandler(&amp;c.ComponentConfig, separateMetrics), <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">if</span> err := c.InsecureServing.Serve(handler, <span class="number">0</span>, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to start healthz server: %v"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> c.InsecureMetricsServing != <span class="literal">nil</span> &#123;</span><br><span class="line">        handler := buildHandlerChain(newMetricsHandler(&amp;c.ComponentConfig), <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">if</span> err := c.InsecureMetricsServing.Serve(handler, <span class="number">0</span>, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to start metrics server: %v"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> c.SecureServing != <span class="literal">nil</span> &#123;</span><br><span class="line">        handler := buildHandlerChain(newHealthzHandler(&amp;c.ComponentConfig, <span class="literal">false</span>), c.Authentication.Authenticator, c.Authorization.Authorizer)</span><br><span class="line">        <span class="keyword">if</span> err := c.SecureServing.Serve(handler, <span class="number">0</span>, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// fail early for secure handlers, removing the old error loop from above</span></span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to start healthz server: %v"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start all informers. 启动pod informer watch pod的变化</span></span><br><span class="line">    <span class="keyword">go</span> c.PodInformer.Informer().Run(stopCh)</span><br><span class="line">    c.InformerFactory.Start(stopCh)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for all caches to sync before scheduling.</span></span><br><span class="line">    c.InformerFactory.WaitForCacheSync(stopCh)</span><br><span class="line">    controller.WaitForCacheSync(<span class="string">"scheduler"</span>, stopCh, c.PodInformer.Informer().HasSynced)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare a reusable run function.</span></span><br><span class="line">    run := <span class="function"><span class="keyword">func</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">        sched.Run()     <span class="comment">// 启动协程</span></span><br><span class="line">        &lt;-stopCh</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If leader election is enabled, run via LeaderElector until done and exit.</span></span><br><span class="line">    <span class="keyword">if</span> c.LeaderElection != <span class="literal">nil</span> &#123;    <span class="comment">// 选举leader</span></span><br><span class="line">        c.LeaderElection.Callbacks = leaderelection.LeaderCallbacks&#123;</span><br><span class="line">            OnStartedLeading: run,</span><br><span class="line">            OnStoppedLeading: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                utilruntime.HandleError(fmt.Errorf(<span class="string">"lost master"</span>))</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">        leaderElector, err := leaderelection.NewLeaderElector(*c.LeaderElection)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"couldn't create leader elector: %v"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        leaderElector.Run()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"lost lease"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Leader election is disabled, so run inline until done.</span></span><br><span class="line">    run(stopCh) <span class="comment">// 启动调度</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">"finished without leader elect"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="func-NewSchedulerConfig-s-schedulerserverconfig-CompletedConfig"><a href="#func-NewSchedulerConfig-s-schedulerserverconfig-CompletedConfig" class="headerlink" title="func NewSchedulerConfig(s schedulerserverconfig.CompletedConfig)"></a><code>func NewSchedulerConfig(s schedulerserverconfig.CompletedConfig)</code></h2><p><a href="https://github.com/kubernetes/kubernetes/blob/v1.11.7/cmd/kube-scheduler/app/server.go#L271" target="_blank" rel="noopener"><code>kubernetes/cmd/kube-scheduler/app/server.go</code></a><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewSchedulerConfig creates the scheduler configuration. This is exposed for use by tests.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSchedulerConfig</span><span class="params">(s schedulerserverconfig.CompletedConfig)</span> <span class="params">(*scheduler.Config, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> storageClassInformer storageinformers.StorageClassInformer</span><br><span class="line">    <span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.VolumeScheduling) &#123;</span><br><span class="line">        storageClassInformer = s.InformerFactory.Storage().V1().StorageClasses()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up the configurator which can create schedulers from configs.</span></span><br><span class="line">    configurator := factory.NewConfigFactory(</span><br><span class="line">        s.ComponentConfig.SchedulerName,</span><br><span class="line">        s.Client,</span><br><span class="line">        s.InformerFactory.Core().V1().Nodes(),</span><br><span class="line">        s.PodInformer,</span><br><span class="line">        s.InformerFactory.Core().V1().PersistentVolumes(),</span><br><span class="line">        s.InformerFactory.Core().V1().PersistentVolumeClaims(),</span><br><span class="line">        s.InformerFactory.Core().V1().ReplicationControllers(),</span><br><span class="line">        s.InformerFactory.Extensions().V1beta1().ReplicaSets(),</span><br><span class="line">        s.InformerFactory.Apps().V1beta1().StatefulSets(),</span><br><span class="line">        s.InformerFactory.Core().V1().Services(),</span><br><span class="line">        s.InformerFactory.Policy().V1beta1().PodDisruptionBudgets(),</span><br><span class="line">        storageClassInformer,</span><br><span class="line">        s.ComponentConfig.HardPodAffinitySymmetricWeight,</span><br><span class="line">        utilfeature.DefaultFeatureGate.Enabled(features.EnableEquivalenceClassCache),</span><br><span class="line">        s.ComponentConfig.DisablePreemption,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    source := s.ComponentConfig.AlgorithmSource</span><br><span class="line">    <span class="keyword">var</span> config *scheduler.Config</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> source.Provider != <span class="literal">nil</span>:</span><br><span class="line">        <span class="comment">// Create the config from a named algorithm provider.</span></span><br><span class="line">        sc, err := configurator.CreateFromProvider(*source.Provider)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"couldn't create scheduler using provider %q: %v"</span>, *source.Provider, err)</span><br><span class="line">        &#125;</span><br><span class="line">        config = sc</span><br><span class="line">    <span class="keyword">case</span> source.Policy != <span class="literal">nil</span>:</span><br><span class="line">        <span class="comment">// Create the config from a user specified policy source.</span></span><br><span class="line">        policy := &amp;schedulerapi.Policy&#123;&#125;</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> source.Policy.File != <span class="literal">nil</span>:</span><br><span class="line">            <span class="comment">// Use a policy serialized in a file.</span></span><br><span class="line">            policyFile := source.Policy.File.Path</span><br><span class="line">            _, err := os.Stat(policyFile)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"missing policy config file %s"</span>, policyFile)</span><br><span class="line">            &#125;</span><br><span class="line">            data, err := ioutil.ReadFile(policyFile)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"couldn't read policy config: %v"</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">            err = runtime.DecodeInto(latestschedulerapi.Codec, []<span class="keyword">byte</span>(data), policy)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"invalid policy: %v"</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> source.Policy.ConfigMap != <span class="literal">nil</span>:</span><br><span class="line">            <span class="comment">// Use a policy serialized in a config map value.</span></span><br><span class="line">            policyRef := source.Policy.ConfigMap</span><br><span class="line">            policyConfigMap, err := s.Client.CoreV1().ConfigMaps(policyRef.Namespace).Get(policyRef.Name, metav1.GetOptions&#123;&#125;)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"couldn't get policy config map %s/%s: %v"</span>, policyRef.Namespace, policyRef.Name, err)</span><br><span class="line">            &#125;</span><br><span class="line">            data, found := policyConfigMap.Data[componentconfig.SchedulerPolicyConfigMapKey]</span><br><span class="line">            <span class="keyword">if</span> !found &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"missing policy config map value at key %q"</span>, componentconfig.SchedulerPolicyConfigMapKey)</span><br><span class="line">            &#125;</span><br><span class="line">            err = runtime.DecodeInto(latestschedulerapi.Codec, []<span class="keyword">byte</span>(data), policy)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"invalid policy: %v"</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sc, err := configurator.CreateFromConfig(*policy)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"couldn't create scheduler from policy: %v"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        config = sc</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unsupported algorithm source: %v"</span>, source)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Additional tweaks to the config produced by the configurator.</span></span><br><span class="line">    config.Recorder = s.Recorder</span><br><span class="line"></span><br><span class="line">    config.DisablePreemption = s.ComponentConfig.DisablePreemption</span><br><span class="line">    <span class="keyword">return</span> config, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="func-NewConfigFactory-……"><a href="#func-NewConfigFactory-……" class="headerlink" title="func NewConfigFactory(……)"></a><code>func NewConfigFactory(……)</code></h2><p><a href="https://github.com/kubernetes/kubernetes/blob/v1.11.7/pkg/scheduler/factory/factory.go#L144" target="_blank" rel="noopener"><code>kubernetes/pkg/scheduler/factory/factory.go</code></a><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewConfigFactory initializes the default implementation of a Configurator To encourage eventual privatization of the struct type, we only</span></span><br><span class="line"><span class="comment">// return the interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConfigFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    schedulerName <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    client clientset.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">    nodeInformer coreinformers.NodeInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">    podInformer coreinformers.PodInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">    pvInformer coreinformers.PersistentVolumeInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">    pvcInformer coreinformers.PersistentVolumeClaimInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">    replicationControllerInformer coreinformers.ReplicationControllerInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">    replicaSetInformer extensionsinformers.ReplicaSetInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">    statefulSetInformer appsinformers.StatefulSetInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">    serviceInformer coreinformers.ServiceInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">    pdbInformer policyinformers.PodDisruptionBudgetInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">    storageClassInformer storageinformers.StorageClassInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">    hardPodAffinitySymmetricWeight <span class="keyword">int32</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    enableEquivalenceClassCache <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    disablePreemption <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="title">scheduler</span>.<span class="title">Configurator</span></span> &#123;</span><br><span class="line">    stopEverything := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    schedulerCache := schedulercache.New(<span class="number">30</span>*time.Second, stopEverything)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// storageClassInformer is only enabled through VolumeScheduling feature gate</span></span><br><span class="line">    <span class="keyword">var</span> storageClassLister storagelisters.StorageClassLister</span><br><span class="line">    <span class="keyword">if</span> storageClassInformer != <span class="literal">nil</span> &#123;</span><br><span class="line">        storageClassLister = storageClassInformer.Lister()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c := &amp;configFactory&#123;</span><br><span class="line">        client:                         client,</span><br><span class="line">        podLister:                      schedulerCache,</span><br><span class="line">        podQueue:                       core.NewSchedulingQueue(),</span><br><span class="line">        pVLister:                       pvInformer.Lister(),</span><br><span class="line">        pVCLister:                      pvcInformer.Lister(),</span><br><span class="line">        serviceLister:                  serviceInformer.Lister(),</span><br><span class="line">        controllerLister:               replicationControllerInformer.Lister(),</span><br><span class="line">        replicaSetLister:               replicaSetInformer.Lister(),</span><br><span class="line">        statefulSetLister:              statefulSetInformer.Lister(),</span><br><span class="line">        pdbLister:                      pdbInformer.Lister(),</span><br><span class="line">        storageClassLister:             storageClassLister,</span><br><span class="line">        schedulerCache:                 schedulerCache,</span><br><span class="line">        StopEverything:                 stopEverything,</span><br><span class="line">        schedulerName:                  schedulerName,</span><br><span class="line">        hardPodAffinitySymmetricWeight: hardPodAffinitySymmetricWeight,</span><br><span class="line">        enableEquivalenceClassCache:    enableEquivalenceClassCache,</span><br><span class="line">        disablePreemption:              disablePreemption,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.scheduledPodsHasSynced = podInformer.Informer().HasSynced</span><br><span class="line">    <span class="comment">// 添加各个处理函数</span></span><br><span class="line">    <span class="comment">// scheduled pod cache</span></span><br><span class="line">    podInformer.Informer().AddEventHandler(</span><br><span class="line">        cache.FilteringResourceEventHandler&#123;</span><br><span class="line">            FilterFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> t := obj.(<span class="keyword">type</span>) &#123;</span><br><span class="line">                <span class="keyword">case</span> *v1.Pod:</span><br><span class="line">                    <span class="keyword">return</span> assignedNonTerminatedPod(t)</span><br><span class="line">                <span class="keyword">case</span> cache.DeletedFinalStateUnknown:</span><br><span class="line">                    <span class="keyword">if</span> pod, ok := t.Obj.(*v1.Pod); ok &#123;</span><br><span class="line">                        <span class="keyword">return</span> assignedNonTerminatedPod(pod)</span><br><span class="line">                    &#125;</span><br><span class="line">                    runtime.HandleError(fmt.Errorf(<span class="string">"unable to convert object %T to *v1.Pod in %T"</span>, obj, c))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    runtime.HandleError(fmt.Errorf(<span class="string">"unable to handle object in %T: %T"</span>, c, obj))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            Handler: cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">                AddFunc:    c.addPodToCache,</span><br><span class="line">                UpdateFunc: c.updatePodInCache,</span><br><span class="line">                DeleteFunc: c.deletePodFromCache,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// unscheduled pod queue</span></span><br><span class="line">    podInformer.Informer().AddEventHandler(</span><br><span class="line">        cache.FilteringResourceEventHandler&#123;</span><br><span class="line">            FilterFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> t := obj.(<span class="keyword">type</span>) &#123;</span><br><span class="line">                <span class="keyword">case</span> *v1.Pod:</span><br><span class="line">                    <span class="keyword">return</span> unassignedNonTerminatedPod(t) &amp;&amp; responsibleForPod(t, schedulerName)</span><br><span class="line">                <span class="keyword">case</span> cache.DeletedFinalStateUnknown:</span><br><span class="line">                    <span class="keyword">if</span> pod, ok := t.Obj.(*v1.Pod); ok &#123;</span><br><span class="line">                        <span class="keyword">return</span> unassignedNonTerminatedPod(pod) &amp;&amp; responsibleForPod(pod, schedulerName)</span><br><span class="line">                    &#125;</span><br><span class="line">                    runtime.HandleError(fmt.Errorf(<span class="string">"unable to convert object %T to *v1.Pod in %T"</span>, obj, c))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    runtime.HandleError(fmt.Errorf(<span class="string">"unable to handle object in %T: %T"</span>, c, obj))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            Handler: cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">                AddFunc:    c.addPodToSchedulingQueue,</span><br><span class="line">                UpdateFunc: c.updatePodInSchedulingQueue,</span><br><span class="line">                DeleteFunc: c.deletePodFromSchedulingQueue,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// ScheduledPodLister is something we provide to plug-in functions that</span></span><br><span class="line">    <span class="comment">// they may need to call.</span></span><br><span class="line">    c.scheduledPodLister = assignedPodLister&#123;podInformer.Lister()&#125;</span><br><span class="line"></span><br><span class="line">    nodeInformer.Informer().AddEventHandler(</span><br><span class="line">        cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">            AddFunc:    c.addNodeToCache,</span><br><span class="line">            UpdateFunc: c.updateNodeInCache,</span><br><span class="line">            DeleteFunc: c.deleteNodeFromCache,</span><br><span class="line">        &#125;,</span><br><span class="line">    )</span><br><span class="line">    c.nodeLister = nodeInformer.Lister()</span><br><span class="line"></span><br><span class="line">    pdbInformer.Informer().AddEventHandler(</span><br><span class="line">        cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">            AddFunc:    c.addPDBToCache,</span><br><span class="line">            UpdateFunc: c.updatePDBInCache,</span><br><span class="line">            DeleteFunc: c.deletePDBFromCache,</span><br><span class="line">        &#125;,</span><br><span class="line">    )</span><br><span class="line">    c.pdbLister = pdbInformer.Lister()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// On add and delete of PVs, it will affect equivalence cache items</span></span><br><span class="line">    <span class="comment">// related to persistent volume</span></span><br><span class="line">    pvInformer.Informer().AddEventHandler(</span><br><span class="line">        cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">            <span class="comment">// MaxPDVolumeCountPredicate: since it relies on the counts of PV.</span></span><br><span class="line">            AddFunc:    c.onPvAdd,</span><br><span class="line">            UpdateFunc: c.onPvUpdate,</span><br><span class="line">            DeleteFunc: c.onPvDelete,</span><br><span class="line">        &#125;,</span><br><span class="line">    )</span><br><span class="line">    c.pVLister = pvInformer.Lister()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is for MaxPDVolumeCountPredicate: add/delete PVC will affect counts of PV when it is bound.</span></span><br><span class="line">    pvcInformer.Informer().AddEventHandler(</span><br><span class="line">        cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">            AddFunc:    c.onPvcAdd,</span><br><span class="line">            UpdateFunc: c.onPvcUpdate,</span><br><span class="line">            DeleteFunc: c.onPvcDelete,</span><br><span class="line">        &#125;,</span><br><span class="line">    )</span><br><span class="line">    c.pVCLister = pvcInformer.Lister()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is for ServiceAffinity: affected by the selector of the service is updated.</span></span><br><span class="line">    <span class="comment">// Also, if new service is added, equivalence cache will also become invalid since</span></span><br><span class="line">    <span class="comment">// existing pods may be "captured" by this service and change this predicate result.</span></span><br><span class="line">    serviceInformer.Informer().AddEventHandler(</span><br><span class="line">        cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">            AddFunc:    c.onServiceAdd,</span><br><span class="line">            UpdateFunc: c.onServiceUpdate,</span><br><span class="line">            DeleteFunc: c.onServiceDelete,</span><br><span class="line">        &#125;,</span><br><span class="line">    )</span><br><span class="line">    c.serviceLister = serviceInformer.Lister()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Existing equivalence cache should not be affected by add/delete RC/Deployment etc,</span></span><br><span class="line">    <span class="comment">// it only make sense when pod is scheduled or deleted</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.VolumeScheduling) &#123;</span><br><span class="line">        <span class="comment">// Setup volume binder</span></span><br><span class="line">        c.volumeBinder = volumebinder.NewVolumeBinder(client, pvcInformer, pvInformer, storageClassInformer)</span><br><span class="line"></span><br><span class="line">        storageClassInformer.Informer().AddEventHandler(</span><br><span class="line">            cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">                AddFunc:    c.onStorageClassAdd,</span><br><span class="line">                DeleteFunc: c.onStorageClassDelete,</span><br><span class="line">            &#125;,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup cache comparer</span></span><br><span class="line">    comparer := &amp;cacheComparer&#123;</span><br><span class="line">        podLister:  podInformer.Lister(),</span><br><span class="line">        nodeLister: nodeInformer.Lister(),</span><br><span class="line">        pdbLister:  pdbInformer.Lister(),</span><br><span class="line">        cache:      c.schedulerCache,</span><br><span class="line">        podQueue:   c.podQueue,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">    signal.Notify(ch, compareSignal)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-c.StopEverything:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">                comparer.Compare()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="func-sched-Scheduler-Run"><a href="#func-sched-Scheduler-Run" class="headerlink" title="func (sched *Scheduler) Run()"></a><code>func (sched *Scheduler) Run()</code></h2><p><a href="https://github.com/kubernetes/kubernetes/blob/v1.11.7/pkg/scheduler/scheduler.go#L176" target="_blank" rel="noopener"><code>kubernetes/pkg/scheduler/scheduler.go</code></a><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run begins watching and scheduling. It waits for cache to be synced, then starts a goroutine and returns immediately.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !sched.config.WaitForCacheSync() &#123;   <span class="comment">// 检查内存是否同步，如果未同步直接return</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.VolumeScheduling) &#123;</span><br><span class="line">        <span class="keyword">go</span> sched.config.VolumeBinder.Run(sched.bindVolumesWorker, sched.config.StopEverything)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> wait.Until(sched.scheduleOne, <span class="number">0</span>, sched.config.StopEverything)    <span class="comment">// 循环执行scheduleOne</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="func-sched-Scheduler-scheduleOne"><a href="#func-sched-Scheduler-scheduleOne" class="headerlink" title="func (sched *Scheduler) scheduleOne()"></a><code>func (sched *Scheduler) scheduleOne()</code></h2><p><a href="https://github.com/kubernetes/kubernetes/blob/v1.11.7/pkg/scheduler/scheduler.go#L460" target="_blank" rel="noopener"><code>kubernetes/pkg/scheduler/scheduler.go</code></a><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scheduleOne does the entire scheduling workflow for a single pod.  It is serialized on the scheduling algorithm's host fitting.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">scheduleOne</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pod := sched.config.NextPod()   <span class="comment">// 从FIFO queue中取出一个需要调度的pod</span></span><br><span class="line">    <span class="keyword">if</span> pod.DeletionTimestamp != <span class="literal">nil</span> &#123;   <span class="comment">// 检查是否是terminate的</span></span><br><span class="line">        sched.config.Recorder.Eventf(pod, v1.EventTypeWarning, <span class="string">"FailedScheduling"</span>, <span class="string">"skip schedule deleting pod: %v/%v"</span>, pod.Namespace, pod.Name)</span><br><span class="line">        glog.V(<span class="number">3</span>).Infof(<span class="string">"Skip schedule deleting pod: %v/%v"</span>, pod.Namespace, pod.Name)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glog.V(<span class="number">3</span>).Infof(<span class="string">"Attempting to schedule pod: %v/%v"</span>, pod.Namespace, pod.Name)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Synchronously attempt to find a fit for the pod.</span></span><br><span class="line">    start := time.Now()</span><br><span class="line">    suggestedHost, err := sched.schedule(pod)   <span class="comment">// 执行调度算法，执行配置的预选和优选策略，选择最适合pod部署的node</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// schedule() may have failed because the pod would not fit on any host, so we try to</span></span><br><span class="line">        <span class="comment">// preempt, with the expectation that the next time the pod is tried for scheduling it</span></span><br><span class="line">        <span class="comment">// will fit due to the preemption. It is also possible that a different pod will schedule</span></span><br><span class="line">        <span class="comment">// into the resources that were preempted, but this is harmless.</span></span><br><span class="line">        <span class="keyword">if</span> fitError, ok := err.(*core.FitError); ok &#123;   <span class="comment">// 如果调度返回预选和优选策略失败，则进行PodPriority优先调度</span></span><br><span class="line">            preemptionStartTime := time.Now()</span><br><span class="line">            sched.preempt(pod, fitError)</span><br><span class="line">            metrics.PreemptionAttempts.Inc()</span><br><span class="line">            metrics.SchedulingAlgorithmPremptionEvaluationDuration.Observe(metrics.SinceInMicroseconds(preemptionStartTime))</span><br><span class="line">            metrics.SchedulingLatency.WithLabelValues(metrics.PreemptionEvaluation).Observe(metrics.SinceInSeconds(preemptionStartTime))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    metrics.SchedulingAlgorithmLatency.Observe(metrics.SinceInMicroseconds(start))</span><br><span class="line">    <span class="comment">// Tell the cache to assume that a pod now is running on a given node, even though it hasn't been bound yet.</span></span><br><span class="line">    <span class="comment">// This allows us to keep scheduling without waiting on binding to occur.</span></span><br><span class="line">    assumedPod := pod.DeepCopy()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assume volumes first before assuming the pod.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If no volumes need binding, then nil is returned, and continue to assume the pod.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Otherwise, error is returned and volume binding is started asynchronously for all of the pod's volumes.</span></span><br><span class="line">    <span class="comment">// scheduleOne() returns immediately on error, so that it doesn't continue to assume the pod.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// After the asynchronous volume binding updates are made, it will send the pod back through the scheduler for</span></span><br><span class="line">    <span class="comment">// subsequent passes until all volumes are fully bound.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This function modifies 'assumedPod' if volume binding is required.</span></span><br><span class="line">    err = sched.assumeAndBindVolumes(assumedPod, suggestedHost) <span class="comment">// 确保volumes bind到pod</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assume modifies `assumedPod` by setting NodeName=suggestedHost</span></span><br><span class="line">    err = sched.assume(assumedPod, suggestedHost)   <span class="comment">// 确保pod到将要调度的node</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bind the pod to its host asynchronously (we can do this b/c of the assumption step above).</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        err := sched.bind(assumedPod, &amp;v1.Binding&#123;  <span class="comment">// bind pod到选出来的node</span></span><br><span class="line">            ObjectMeta: metav1.ObjectMeta&#123;Namespace: assumedPod.Namespace, Name: assumedPod.Name, UID: assumedPod.UID&#125;,</span><br><span class="line">            Target: v1.ObjectReference&#123;</span><br><span class="line">                Kind: <span class="string">"Node"</span>,</span><br><span class="line">                Name: suggestedHost,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">        metrics.E2eSchedulingLatency.Observe(metrics.SinceInMicroseconds(start))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            glog.Errorf(<span class="string">"Internal error binding pod: (%v)"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Scheduler.scheduleOne</code>执行Scheduler真正的调度逻辑，每次从PodQueue中取出一个pod调度：</p>
<ul>
<li>从PodQueue中取出一个pod</li>
<li>检查是否是需要删除的Pod，如果是则返回error</li>
<li>执行ScheduleAlgorithm的Schedule接口，进行预选和优选，选出适合的node</li>
<li>如果预选及优选失败，执行Scheduler.preempt方法检查是否开启PodPriority优先调度，如果开启了则进行PodPriority优先调度</li>
<li>assume pod以及assume bound volume</li>
<li>bind pod，如果bind失败，写失败日志</li>
</ul>
<h2 id="func-sched-Scheduler-schedule-pod-v1-Pod"><a href="#func-sched-Scheduler-schedule-pod-v1-Pod" class="headerlink" title="func (sched *Scheduler) schedule(pod *v1.Pod)"></a><code>func (sched *Scheduler) schedule(pod *v1.Pod)</code></h2><p><a href="https://github.com/kubernetes/kubernetes/blob/v1.11.7/pkg/scheduler/scheduler.go#L194" target="_blank" rel="noopener"><code>kubernetes/pkg/scheduler/scheduler.go</code></a><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// schedule implements the scheduling algorithm and returns the suggested host.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">schedule</span><span class="params">(pod *v1.Pod)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    host, err := sched.config.Algorithm.Schedule(pod, sched.config.NodeLister)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.V(<span class="number">1</span>).Infof(<span class="string">"Failed to schedule pod: %v/%v"</span>, pod.Namespace, pod.Name)</span><br><span class="line">        pod = pod.DeepCopy()</span><br><span class="line">        sched.config.Error(pod, err)</span><br><span class="line">        sched.config.Recorder.Eventf(pod, v1.EventTypeWarning, <span class="string">"FailedScheduling"</span>, <span class="string">"%v"</span>, err)</span><br><span class="line">        sched.config.PodConditionUpdater.Update(pod, &amp;v1.PodCondition&#123;</span><br><span class="line">            Type:          v1.PodScheduled,</span><br><span class="line">            Status:        v1.ConditionFalse,</span><br><span class="line">            LastProbeTime: metav1.Now(),</span><br><span class="line">            Reason:        v1.PodReasonUnschedulable,</span><br><span class="line">            Message:       err.Error(),</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> host, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="func-g-genericScheduler-Schedule-pod-v1-Pod-nodeLister-algorithm-NodeLister"><a href="#func-g-genericScheduler-Schedule-pod-v1-Pod-nodeLister-algorithm-NodeLister" class="headerlink" title="func (g *genericScheduler) Schedule(pod *v1.Pod, nodeLister algorithm.NodeLister)"></a><code>func (g *genericScheduler) Schedule(pod *v1.Pod, nodeLister algorithm.NodeLister)</code></h2><p><a href="https://github.com/kubernetes/kubernetes/blob/v1.11.7/pkg/scheduler/core/generic_scheduler.go#L107" target="_blank" rel="noopener"><code>kubernetes/pkg/scheduler/core/generic_scheduler.go</code></a><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Schedule tries to schedule the given pod to one of the nodes in the node list.</span></span><br><span class="line"><span class="comment">// If it succeeds, it will return the name of the node.</span></span><br><span class="line"><span class="comment">// If it fails, it will return a FitError error with reasons.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *genericScheduler)</span> <span class="title">Schedule</span><span class="params">(pod *v1.Pod, nodeLister algorithm.NodeLister)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    trace := utiltrace.New(fmt.Sprintf(<span class="string">"Scheduling %s/%s"</span>, pod.Namespace, pod.Name))</span><br><span class="line">    <span class="keyword">defer</span> trace.LogIfLong(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">    <span class="comment">// 对pod做检查，如果使用pvc，判断pvc是否存在</span></span><br><span class="line">    <span class="keyword">if</span> err := podPassesBasicChecks(pod, g.pvcLister); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取所有的nodes</span></span><br><span class="line">    nodes, err := nodeLister.List()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nodes) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, ErrNoNodesAvailable</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Used for all fit and priority funcs.</span></span><br><span class="line">    err = g.cache.UpdateNodeNameToInfoMap(g.cachedNodeInfoMap)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trace.Step(<span class="string">"Computing predicates"</span>)</span><br><span class="line">    startPredicateEvalTime := time.Now()</span><br><span class="line">    <span class="comment">// 预选</span></span><br><span class="line">    filteredNodes, failedPredicateMap, err := g.findNodesThatFit(pod, nodes)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(filteredNodes) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, &amp;FitError&#123;</span><br><span class="line">            Pod:              pod,</span><br><span class="line">            NumAllNodes:      <span class="built_in">len</span>(nodes),</span><br><span class="line">            FailedPredicates: failedPredicateMap,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    metrics.SchedulingAlgorithmPredicateEvaluationDuration.Observe(metrics.SinceInMicroseconds(startPredicateEvalTime))</span><br><span class="line">    metrics.SchedulingLatency.WithLabelValues(metrics.PredicateEvaluation).Observe(metrics.SinceInSeconds(startPredicateEvalTime))</span><br><span class="line"></span><br><span class="line">    trace.Step(<span class="string">"Prioritizing"</span>)</span><br><span class="line">    startPriorityEvalTime := time.Now()</span><br><span class="line">    <span class="comment">// When only one node after predicate, just use it.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(filteredNodes) == <span class="number">1</span> &#123;</span><br><span class="line">        metrics.SchedulingAlgorithmPriorityEvaluationDuration.Observe(metrics.SinceInMicroseconds(startPriorityEvalTime))</span><br><span class="line">        <span class="keyword">return</span> filteredNodes[<span class="number">0</span>].Name, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 优选</span></span><br><span class="line">    metaPrioritiesInterface := g.priorityMetaProducer(pod, g.cachedNodeInfoMap)</span><br><span class="line">    priorityList, err := PrioritizeNodes(pod, g.cachedNodeInfoMap, metaPrioritiesInterface, g.prioritizers, filteredNodes, g.extenders)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    metrics.SchedulingAlgorithmPriorityEvaluationDuration.Observe(metrics.SinceInMicroseconds(startPriorityEvalTime))</span><br><span class="line">    metrics.SchedulingLatency.WithLabelValues(metrics.PriorityEvaluation).Observe(metrics.SinceInSeconds(startPriorityEvalTime))</span><br><span class="line"></span><br><span class="line">    trace.Step(<span class="string">"Selecting host"</span>)</span><br><span class="line">    <span class="keyword">return</span> g.selectHost(priorityList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果自定义调度器，则启用默认的调度器genericScheduler，方法如下：</p>
<ul>
<li>对pod做一些基础检查，如pvc</li>
<li>获取Node List</li>
<li>执行genericScheduler.findNodesThatFit方法进行预选</li>
<li>执行PrioritizeNodes方法对通过预选的node进行优选打分</li>
<li>最后找出一个优选分数最高的node，如果优选分数一样，则随机返回一个分数最高的node</li>
</ul>
<h2 id="func-g-genericScheduler-findNodesThatFit-pod-v1-Pod-nodes-v1-Node"><a href="#func-g-genericScheduler-findNodesThatFit-pod-v1-Pod-nodes-v1-Node" class="headerlink" title="func (g *genericScheduler) findNodesThatFit(pod *v1.Pod, nodes []*v1.Node)"></a><code>func (g *genericScheduler) findNodesThatFit(pod *v1.Pod, nodes []*v1.Node)</code></h2><p><a href="https://github.com/kubernetes/kubernetes/blob/v1.11.7/pkg/scheduler/core/generic_scheduler.go#L333" target="_blank" rel="noopener"><code>kubernetes/pkg/scheduler/core/generic_scheduler.go</code></a><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Filters the nodes to find the ones that fit based on the given predicate functions</span></span><br><span class="line"><span class="comment">// Each node is passed through the predicate functions to determine if it is a fit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *genericScheduler)</span> <span class="title">findNodesThatFit</span><span class="params">(pod *v1.Pod, nodes []*v1.Node)</span> <span class="params">([]*v1.Node, FailedPredicateMap, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> filtered []*v1.Node</span><br><span class="line">    failedPredicateMap := FailedPredicateMap&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(g.predicates) == <span class="number">0</span> &#123;</span><br><span class="line">        filtered = nodes</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Create filtered list with enough space to avoid growing it</span></span><br><span class="line">        <span class="comment">// and allow assigning.</span></span><br><span class="line">        filtered = <span class="built_in">make</span>([]*v1.Node, <span class="built_in">len</span>(nodes))</span><br><span class="line">        errs := errors.MessageCountMap&#123;&#125;</span><br><span class="line">        <span class="keyword">var</span> predicateResultLock sync.Mutex</span><br><span class="line">        <span class="keyword">var</span> filteredLen <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can use the same metadata producer for all nodes.</span></span><br><span class="line">        meta := g.predicateMetaProducer(pod, g.cachedNodeInfoMap)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> equivCacheInfo *equivalenceClassInfo</span><br><span class="line">        <span class="keyword">if</span> g.equivalenceCache != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// getEquivalenceClassInfo will return immediately if no equivalence pod found</span></span><br><span class="line">            equivCacheInfo = g.equivalenceCache.getEquivalenceClassInfo(pod)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        checkNode := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            nodeName := nodes[i].Name</span><br><span class="line">            fits, failedPredicates, err := podFitsOnNode(</span><br><span class="line">                pod,</span><br><span class="line">                meta,</span><br><span class="line">                g.cachedNodeInfoMap[nodeName],</span><br><span class="line">                g.predicates,</span><br><span class="line">                g.cache,</span><br><span class="line">                g.equivalenceCache,</span><br><span class="line">                g.schedulingQueue,</span><br><span class="line">                g.alwaysCheckAllPredicates,</span><br><span class="line">                equivCacheInfo,</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                predicateResultLock.Lock()</span><br><span class="line">                errs[err.Error()]++</span><br><span class="line">                predicateResultLock.Unlock()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> fits &#123;</span><br><span class="line">                filtered[atomic.AddInt32(&amp;filteredLen, <span class="number">1</span>)<span class="number">-1</span>] = nodes[i]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                predicateResultLock.Lock()</span><br><span class="line">                failedPredicateMap[nodeName] = failedPredicates</span><br><span class="line">                predicateResultLock.Unlock()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        workqueue.Parallelize(<span class="number">16</span>, <span class="built_in">len</span>(nodes), checkNode)</span><br><span class="line">        filtered = filtered[:filteredLen]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(errs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> []*v1.Node&#123;&#125;, FailedPredicateMap&#123;&#125;, errors.CreateAggregateFromMessageCountMap(errs)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(filtered) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(g.extenders) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, extender := <span class="keyword">range</span> g.extenders &#123;</span><br><span class="line">            <span class="keyword">if</span> !extender.IsInterested(pod) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            filteredList, failedMap, err := extender.Filter(pod, filtered, g.cachedNodeInfoMap)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> extender.IsIgnorable() &#123;</span><br><span class="line">                    glog.Warningf(<span class="string">"Skipping extender %v as it returned error %v and has ignorable flag set"</span>,</span><br><span class="line">                        extender, err)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> []*v1.Node&#123;&#125;, FailedPredicateMap&#123;&#125;, err</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> failedNodeName, failedMsg := <span class="keyword">range</span> failedMap &#123;</span><br><span class="line">                <span class="keyword">if</span> _, found := failedPredicateMap[failedNodeName]; !found &#123;</span><br><span class="line">                    failedPredicateMap[failedNodeName] = []algorithm.PredicateFailureReason&#123;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">                failedPredicateMap[failedNodeName] = <span class="built_in">append</span>(failedPredicateMap[failedNodeName], predicates.NewFailureReason(failedMsg))</span><br><span class="line">            &#125;</span><br><span class="line">            filtered = filteredList</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(filtered) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> filtered, failedPredicateMap, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>CheckNode调用podFitsOnNode函数，用配置的所有的predicate policy对node进行检查</li>
<li>根据node数量，启动多个go routine worker进行CheckNode</li>
<li>如果配置了extender，则再执行extender对node进行筛选</li>
</ul>
<h2 id="func-podFitsOnNode-……"><a href="#func-podFitsOnNode-……" class="headerlink" title="func podFitsOnNode(……)"></a><code>func podFitsOnNode(……)</code></h2><p><a href="https://github.com/kubernetes/kubernetes/blob/v1.11.7/pkg/scheduler/core/generic_scheduler.go#L461" target="_blank" rel="noopener"><code>kubernetes/pkg/scheduler/core/generic_scheduler.go</code></a><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// podFitsOnNode checks whether a node given by NodeInfo satisfies the given predicate functions.</span></span><br><span class="line"><span class="comment">// For given pod, podFitsOnNode will check if any equivalent pod exists and try to reuse its cached</span></span><br><span class="line"><span class="comment">// predicate results as possible.</span></span><br><span class="line"><span class="comment">// This function is called from two different places: Schedule and Preempt.</span></span><br><span class="line"><span class="comment">// When it is called from Schedule, we want to test whether the pod is schedulable</span></span><br><span class="line"><span class="comment">// on the node with all the existing pods on the node plus higher and equal priority</span></span><br><span class="line"><span class="comment">// pods nominated to run on the node.</span></span><br><span class="line"><span class="comment">// When it is called from Preempt, we should remove the victims of preemption and</span></span><br><span class="line"><span class="comment">// add the nominated pods. Removal of the victims is done by SelectVictimsOnNode().</span></span><br><span class="line"><span class="comment">// It removes victims from meta and NodeInfo before calling this function.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">podFitsOnNode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    pod *v1.Pod,</span></span></span><br><span class="line"><span class="function"><span class="params">    meta algorithm.PredicateMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">    info *schedulercache.NodeInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">    predicateFuncs <span class="keyword">map</span>[<span class="keyword">string</span>]algorithm.FitPredicate,</span></span></span><br><span class="line"><span class="function"><span class="params">    cache schedulercache.Cache,</span></span></span><br><span class="line"><span class="function"><span class="params">    ecache *EquivalenceCache,</span></span></span><br><span class="line"><span class="function"><span class="params">    queue SchedulingQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    alwaysCheckAllPredicates <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    equivCacheInfo *equivalenceClassInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(<span class="keyword">bool</span>, []algorithm.PredicateFailureReason, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        eCacheAvailable  <span class="keyword">bool</span></span><br><span class="line">        failedPredicates []algorithm.PredicateFailureReason</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    podsAdded := <span class="literal">false</span></span><br><span class="line">    <span class="comment">// We run predicates twice in some cases. If the node has greater or equal priority</span></span><br><span class="line">    <span class="comment">// nominated pods, we run them when those pods are added to meta and nodeInfo.</span></span><br><span class="line">    <span class="comment">// If all predicates succeed in this pass, we run them again when these</span></span><br><span class="line">    <span class="comment">// nominated pods are not added. This second pass is necessary because some</span></span><br><span class="line">    <span class="comment">// predicates such as inter-pod affinity may not pass without the nominated pods.</span></span><br><span class="line">    <span class="comment">// If there are no nominated pods for the node or if the first run of the</span></span><br><span class="line">    <span class="comment">// predicates fail, we don't run the second pass.</span></span><br><span class="line">    <span class="comment">// We consider only equal or higher priority pods in the first pass, because</span></span><br><span class="line">    <span class="comment">// those are the current "pod" must yield to them and not take a space opened</span></span><br><span class="line">    <span class="comment">// for running them. It is ok if the current "pod" take resources freed for</span></span><br><span class="line">    <span class="comment">// lower priority pods.</span></span><br><span class="line">    <span class="comment">// Requiring that the new pod is schedulable in both circumstances ensures that</span></span><br><span class="line">    <span class="comment">// we are making a conservative decision: predicates like resources and inter-pod</span></span><br><span class="line">    <span class="comment">// anti-affinity are more likely to fail when the nominated pods are treated</span></span><br><span class="line">    <span class="comment">// as running, while predicates like pod affinity are more likely to fail when</span></span><br><span class="line">    <span class="comment">// the nominated pods are treated as not running. We can't just assume the</span></span><br><span class="line">    <span class="comment">// nominated pods are running because they are not running right now and in fact,</span></span><br><span class="line">    <span class="comment">// they may end up getting scheduled to a different node.</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        metaToUse := meta</span><br><span class="line">        nodeInfoToUse := info</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            podsAdded, metaToUse, nodeInfoToUse = addNominatedPods(pod, meta, info, queue)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> !podsAdded || <span class="built_in">len</span>(failedPredicates) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Bypass eCache if node has any nominated pods.</span></span><br><span class="line">        <span class="comment">// TODO(bsalamat): consider using eCache and adding proper eCache invalidations</span></span><br><span class="line">        <span class="comment">// when pods are nominated or their nominations change.</span></span><br><span class="line">        eCacheAvailable = equivCacheInfo != <span class="literal">nil</span> &amp;&amp; !podsAdded</span><br><span class="line">        <span class="keyword">for</span> _, predicateKey := <span class="keyword">range</span> predicates.Ordering() &#123;</span><br><span class="line">            <span class="keyword">var</span> (</span><br><span class="line">                fit     <span class="keyword">bool</span></span><br><span class="line">                reasons []algorithm.PredicateFailureReason</span><br><span class="line">                err     error</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">//TODO (yastij) : compute average predicate restrictiveness to export it as Prometheus metric</span></span><br><span class="line">            <span class="keyword">if</span> predicate, exist := predicateFuncs[predicateKey]; exist &#123;</span><br><span class="line">                <span class="keyword">if</span> eCacheAvailable &#123;</span><br><span class="line">                    fit, reasons, err = ecache.RunPredicate(predicate, predicateKey, pod, metaToUse, nodeInfoToUse, equivCacheInfo, cache)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    fit, reasons, err = predicate(pod, metaToUse, nodeInfoToUse)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>, []algorithm.PredicateFailureReason&#123;&#125;, err</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> !fit &#123;</span><br><span class="line">                    <span class="comment">// eCache is available and valid, and predicates result is unfit, record the fail reasons</span></span><br><span class="line">                    failedPredicates = <span class="built_in">append</span>(failedPredicates, reasons...)</span><br><span class="line">                    <span class="comment">// if alwaysCheckAllPredicates is false, short circuit all predicates when one predicate fails.</span></span><br><span class="line">                    <span class="keyword">if</span> !alwaysCheckAllPredicates &#123;</span><br><span class="line">                        glog.V(<span class="number">5</span>).Infoln(<span class="string">"since alwaysCheckAllPredicates has not been set, the predicate"</span> +</span><br><span class="line">                            <span class="string">"evaluation is short circuited and there are chances"</span> +</span><br><span class="line">                            <span class="string">"of other predicates failing as well."</span>)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(failedPredicates) == <span class="number">0</span>, failedPredicates, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一共会尝试进行两次predicate：</p>
<ul>
<li>第一次predicate时，调用<code>addNominatePods</code>，遍历PriorityQueue nominatedPods中所有的Pods，将那些PodPriority大于等于该调度Pod的优先级的所有nominatedPods添加到SchedulerCache的NodeInfo中，意味着调度该pod时要考虑这些高优先级nominatedPods进行预选，比如要减去他们的resourceRequest等，并更新到PredicateMetadata中，接着执行正常的predicate逻辑</li>
<li>第二次predicate时，如果前面的predicate逻辑有失败的情况，或者前面的podsAdded为false，那么第二次predicate立即结束，并不会触发真正的predicate逻辑</li>
<li>第二次predicate时，如果前面的predicate逻辑都成功，并且podAdded为true的情况下，那么需要触发真正的第二次predicate逻辑，因为nominatedPods的添加成功，可能Inter-PodAffinity会影响predicate的结果</li>
</ul>
<h2 id="func-addNominatedPods-pod-v1-Pod-meta-algorithm-PredicateMetadata-nodeInfo-schedulercache-NodeInfo-queue-SchedulingQueue"><a href="#func-addNominatedPods-pod-v1-Pod-meta-algorithm-PredicateMetadata-nodeInfo-schedulercache-NodeInfo-queue-SchedulingQueue" class="headerlink" title="func addNominatedPods(pod *v1.Pod, meta algorithm.PredicateMetadata, nodeInfo *schedulercache.NodeInfo, queue SchedulingQueue)"></a><code>func addNominatedPods(pod *v1.Pod, meta algorithm.PredicateMetadata, nodeInfo *schedulercache.NodeInfo, queue SchedulingQueue)</code></h2><p><a href="https://github.com/kubernetes/kubernetes/blob/v1.11.7/pkg/scheduler/core/generic_scheduler.go#L424" target="_blank" rel="noopener"><code>kubernetes/pkg/scheduler/core/generic_scheduler.go</code></a><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addNominatedPods adds pods with equal or greater priority which are nominated</span></span><br><span class="line"><span class="comment">// to run on the node given in nodeInfo to meta and nodeInfo. It returns 1) whether</span></span><br><span class="line"><span class="comment">// any pod was found, 2) augmented meta data, 3) augmented nodeInfo.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addNominatedPods</span><span class="params">(pod *v1.Pod, meta algorithm.PredicateMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">    nodeInfo *schedulercache.NodeInfo, queue SchedulingQueue)</span> <span class="params">(<span class="keyword">bool</span>, algorithm.PredicateMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">    *schedulercache.NodeInfo)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> queue == <span class="literal">nil</span> || nodeInfo == <span class="literal">nil</span> || nodeInfo.Node() == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// This may happen only in tests.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>, meta, nodeInfo</span><br><span class="line">    &#125;</span><br><span class="line">    nominatedPods := queue.NominatedPodsForNode(nodeInfo.Node().Name)</span><br><span class="line">    <span class="keyword">if</span> nominatedPods == <span class="literal">nil</span> || <span class="built_in">len</span>(nominatedPods) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>, meta, nodeInfo</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> metaOut algorithm.PredicateMetadata</span><br><span class="line">    <span class="keyword">if</span> meta != <span class="literal">nil</span> &#123;</span><br><span class="line">        metaOut = meta.ShallowCopy()</span><br><span class="line">    &#125;</span><br><span class="line">    nodeInfoOut := nodeInfo.Clone()</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> nominatedPods &#123;</span><br><span class="line">        <span class="keyword">if</span> util.GetPodPriority(p) &gt;= util.GetPodPriority(pod) &amp;&amp; p.UID != pod.UID &#123;</span><br><span class="line">            nodeInfoOut.AddPod(p)</span><br><span class="line">            <span class="keyword">if</span> metaOut != <span class="literal">nil</span> &#123;</span><br><span class="line">                metaOut.AddPod(p, nodeInfoOut)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, metaOut, nodeInfoOut</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>addNominatedPods</code>负责生成临时的schedulercache.NodeInfo和algorithm.PredicateMetadata，提供给具体的predicate Function进行预选处理：</p>
<ul>
<li>调用NominatedPodsForNode获取PriorityQueue中的该node上的nominatedPods cache数据，如果nominatedPods为空，则返回false结束</li>
<li>克隆出PredicateMeta和NodeInfo对象，遍历nominatedPods，将优先级不低于待调度pod的nominatedPods加入到克隆出来的nodeInfoOut和metaOut中，这些对象最终会传入到predicate Functions中进行预选处理</li>
</ul>
<h2 id="func-PrioritizeNodes-……"><a href="#func-PrioritizeNodes-……" class="headerlink" title="func PrioritizeNodes(……)"></a><code>func PrioritizeNodes(……)</code></h2><p><a href="https://github.com/kubernetes/kubernetes/blob/v1.11.7/pkg/scheduler/core/generic_scheduler.go#L549" target="_blank" rel="noopener"><code>kubernetes/pkg/scheduler/core/generic_scheduler.go</code></a><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PrioritizeNodes prioritizes the nodes by running the individual priority functions in parallel.</span></span><br><span class="line"><span class="comment">// Each priority function is expected to set a score of 0-10</span></span><br><span class="line"><span class="comment">// 0 is the lowest priority score (least preferred node) and 10 is the highest</span></span><br><span class="line"><span class="comment">// Each priority function can also have its own weight</span></span><br><span class="line"><span class="comment">// The node scores returned by the priority function are multiplied by the weights to get weighted scores</span></span><br><span class="line"><span class="comment">// All scores are finally combined (added) to get the total weighted scores of all nodes</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrioritizeNodes</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    pod *v1.Pod,</span></span></span><br><span class="line"><span class="function"><span class="params">    nodeNameToInfo <span class="keyword">map</span>[<span class="keyword">string</span>]*schedulercache.NodeInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">    meta <span class="keyword">interface</span>&#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">    priorityConfigs []algorithm.PriorityConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">    nodes []*v1.Node,</span></span></span><br><span class="line"><span class="function"><span class="params">    extenders []algorithm.SchedulerExtender,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(schedulerapi.HostPriorityList, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// If no priority configs are provided, then the EqualPriority function is applied</span></span><br><span class="line">    <span class="comment">// This is required to generate the priority list in the required format</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(priorityConfigs) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(extenders) == <span class="number">0</span> &#123;</span><br><span class="line">        result := <span class="built_in">make</span>(schedulerapi.HostPriorityList, <span class="number">0</span>, <span class="built_in">len</span>(nodes))</span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">            hostPriority, err := EqualPriorityMap(pod, meta, nodeNameToInfo[nodes[i].Name])</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="built_in">append</span>(result, hostPriority)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        mu   = sync.Mutex&#123;&#125;</span><br><span class="line">        wg   = sync.WaitGroup&#123;&#125;</span><br><span class="line">        errs []error</span><br><span class="line">    )</span><br><span class="line">    appendError := <span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">        mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">        errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    results := <span class="built_in">make</span>([]schedulerapi.HostPriorityList, <span class="built_in">len</span>(priorityConfigs), <span class="built_in">len</span>(priorityConfigs))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, priorityConfig := <span class="keyword">range</span> priorityConfigs &#123;</span><br><span class="line">        <span class="keyword">if</span> priorityConfig.Function != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// DEPRECATED</span></span><br><span class="line">            wg.Add(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>, config algorithm.PriorityConfig)</span></span> &#123;</span><br><span class="line">                <span class="keyword">defer</span> wg.Done()</span><br><span class="line">                <span class="keyword">var</span> err error</span><br><span class="line">                results[index], err = config.Function(pod, nodeNameToInfo, nodes)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    appendError(err)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;(i, priorityConfig)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            results[i] = <span class="built_in">make</span>(schedulerapi.HostPriorityList, <span class="built_in">len</span>(nodes))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    processNode := <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        nodeInfo := nodeNameToInfo[nodes[index].Name]</span><br><span class="line">        <span class="keyword">var</span> err error</span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> priorityConfigs &#123;</span><br><span class="line">            <span class="keyword">if</span> priorityConfigs[i].Function != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            results[i][index], err = priorityConfigs[i].Map(pod, meta, nodeInfo)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                appendError(err)</span><br><span class="line">                results[i][index].Host = nodes[index].Name</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    workqueue.Parallelize(<span class="number">16</span>, <span class="built_in">len</span>(nodes), processNode)</span><br><span class="line">    <span class="keyword">for</span> i, priorityConfig := <span class="keyword">range</span> priorityConfigs &#123;</span><br><span class="line">        <span class="keyword">if</span> priorityConfig.Reduce == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>, config algorithm.PriorityConfig)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="keyword">if</span> err := config.Reduce(pod, meta, nodeNameToInfo, results[index]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                appendError(err)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> glog.V(<span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> _, hostPriority := <span class="keyword">range</span> results[index] &#123;</span><br><span class="line">                    glog.Infof(<span class="string">"%v -&gt; %v: %v, Score: (%d)"</span>, pod.Name, hostPriority.Host, config.Name, hostPriority.Score)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i, priorityConfig)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Wait for all computations to be finished.</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(errs) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> schedulerapi.HostPriorityList&#123;&#125;, errors.NewAggregate(errs)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Summarize all scores.</span></span><br><span class="line">    result := <span class="built_in">make</span>(schedulerapi.HostPriorityList, <span class="number">0</span>, <span class="built_in">len</span>(nodes))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, schedulerapi.HostPriority&#123;Host: nodes[i].Name, Score: <span class="number">0</span>&#125;)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="keyword">range</span> priorityConfigs &#123;</span><br><span class="line">            result[i].Score += results[j][i].Score * priorityConfigs[j].Weight</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(extenders) != <span class="number">0</span> &amp;&amp; nodes != <span class="literal">nil</span> &#123;</span><br><span class="line">        combinedScores := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(nodeNameToInfo))</span><br><span class="line">        <span class="keyword">for</span> _, extender := <span class="keyword">range</span> extenders &#123;</span><br><span class="line">            <span class="keyword">if</span> !extender.IsInterested(pod) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            wg.Add(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ext algorithm.SchedulerExtender)</span></span> &#123;</span><br><span class="line">                <span class="keyword">defer</span> wg.Done()</span><br><span class="line">                prioritizedList, weight, err := ext.Prioritize(pod, nodes)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="comment">// Prioritization errors from extender can be ignored, let k8s/other extenders determine the priorities</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                mu.Lock()</span><br><span class="line">                <span class="keyword">for</span> i := <span class="keyword">range</span> *prioritizedList &#123;</span><br><span class="line">                    host, score := (*prioritizedList)[i].Host, (*prioritizedList)[i].Score</span><br><span class="line">                    combinedScores[host] += score * weight</span><br><span class="line">                &#125;</span><br><span class="line">                mu.Unlock()</span><br><span class="line">            &#125;(extender)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// wait for all go routines to finish</span></span><br><span class="line">        wg.Wait()</span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> result &#123;</span><br><span class="line">            result[i].Score += combinedScores[result[i].Host]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> glog.V(<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> result &#123;</span><br><span class="line">            glog.V(<span class="number">10</span>).Infof(<span class="string">"Host %s =&gt; Score %d"</span>, result[i].Host, result[i].Score)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>PrioritizeNodes</code>函数对node进行优选打分：</p>
<ul>
<li>根据预选后的node数量，以及Priority Policies的数量，定义一个二维数组存储每个node的每个Priorities Policy的分数</li>
<li>ProcessNode对单个node遍历所有的Priorities Policy，得到每个node的每次policy的分数</li>
<li>根据通过预选的node数量，最多启动16个go routine worker执行processNode</li>
<li>对所有分数进行加权求和，得到每个node的优选分数</li>
<li>如果配置了extender，则再执行extender的优选打分方法extender.Prioritize，并加权到node的优选分数</li>
</ul>
<h2 id="func-sched-Scheduler-preempt-preemptor-v1-Pod-scheduleErr-error"><a href="#func-sched-Scheduler-preempt-preemptor-v1-Pod-scheduleErr-error" class="headerlink" title="func (sched *Scheduler) preempt(preemptor *v1.Pod, scheduleErr error)"></a><code>func (sched *Scheduler) preempt(preemptor *v1.Pod, scheduleErr error)</code></h2><p><a href="https://github.com/kubernetes/kubernetes/blob/v1.11.7/pkg/scheduler/scheduler.go#L216" target="_blank" rel="noopener"><code>kubernetes/pkg/scheduler/scheduler.go</code></a><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// preempt tries to create room for a pod that has failed to schedule, by preempting lower priority pods if possible.</span></span><br><span class="line"><span class="comment">// If it succeeds, it adds the name of the node where preemption has happened to the pod annotations.</span></span><br><span class="line"><span class="comment">// It returns the node name and an error if any.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">preempt</span><span class="params">(preemptor *v1.Pod, scheduleErr error)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !util.PodPriorityEnabled() || sched.config.DisablePreemption &#123;</span><br><span class="line">        glog.V(<span class="number">3</span>).Infof(<span class="string">"Pod priority feature is not enabled or preemption is disabled by scheduler configuration."</span> +</span><br><span class="line">            <span class="string">" No preemption is performed."</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    preemptor, err := sched.config.PodPreemptor.GetUpdatedPod(preemptor)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">"Error getting the updated preemptor pod object: %v"</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node, victims, nominatedPodsToClear, err := sched.config.Algorithm.Preempt(preemptor, sched.config.NodeLister, scheduleErr)</span><br><span class="line">    metrics.PreemptionVictims.Set(<span class="keyword">float64</span>(<span class="built_in">len</span>(victims)))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">"Error preempting victims to make room for %v/%v."</span>, preemptor.Namespace, preemptor.Name)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> nodeName = <span class="string">""</span></span><br><span class="line">    <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">        nodeName = node.Name</span><br><span class="line">        <span class="comment">// Update the scheduling queue with the nominated pod information. Without</span></span><br><span class="line">        <span class="comment">// this, there would be a race condition between the next scheduling cycle</span></span><br><span class="line">        <span class="comment">// and the time the scheduler receives a Pod Update for the nominated pod.</span></span><br><span class="line">        sched.config.SchedulingQueue.UpdateNominatedPodForNode(preemptor, nodeName)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make a call to update nominated node name of the pod on the API server.</span></span><br><span class="line">        err = sched.config.PodPreemptor.SetNominatedNodeName(preemptor, nodeName)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            glog.Errorf(<span class="string">"Error in preemption process. Cannot update pod %v annotations: %v"</span>, preemptor.Name, err)</span><br><span class="line">            sched.config.SchedulingQueue.DeleteNominatedPodIfExists(preemptor)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, victim := <span class="keyword">range</span> victims &#123;</span><br><span class="line">            <span class="keyword">if</span> err := sched.config.PodPreemptor.DeletePod(victim); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                glog.Errorf(<span class="string">"Error preempting pod %v/%v: %v"</span>, victim.Namespace, victim.Name, err)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">            &#125;</span><br><span class="line">            sched.config.Recorder.Eventf(victim, v1.EventTypeNormal, <span class="string">"Preempted"</span>, <span class="string">"by %v/%v on node %v"</span>, preemptor.Namespace, preemptor.Name, nodeName)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Clearing nominated pods should happen outside of "if node != nil". Node could</span></span><br><span class="line">    <span class="comment">// be nil when a pod with nominated node name is eligible to preempt again,</span></span><br><span class="line">    <span class="comment">// but preemption logic does not find any node for it. In that case Preempt()</span></span><br><span class="line">    <span class="comment">// function of generic_scheduler.go returns the pod itself for removal of the annotation.</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> nominatedPodsToClear &#123;</span><br><span class="line">        rErr := sched.config.PodPreemptor.RemoveNominatedNodeName(p)</span><br><span class="line">        <span class="keyword">if</span> rErr != <span class="literal">nil</span> &#123;</span><br><span class="line">            glog.Errorf(<span class="string">"Cannot remove nominated node annotation of pod: %v"</span>, rErr)</span><br><span class="line">            <span class="comment">// We do not return as this error is not critical.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nodeName, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果预选/优选失败以后，使用<code>Scheduler.preempt</code>方法进行优先级调度：</p>
<ul>
<li>检查PodPriority是否开启，如果未开启则直接返回</li>
<li>由于Pod在Predicate/Priority调度失败后，会更新PodCondition，记录调度失败状态及原因，需从apiserver中获取更新后的Pod</li>
<li>执行scheduler.Preempt方法，选出要执行优先调度的node以及node上要删除的pod</li>
<li>将要调度的pod绑定到上面选出来的node</li>
<li>删除前两步用Preempt方法选出来的要删除的pod</li>
<li>抹去上一步删除的pod与node的绑定信息</li>
</ul>
<h2 id="func-g-genericScheduler-Preempt-pod-v1-Pod-nodeLister-algorithm-NodeLister-scheduleErr-error"><a href="#func-g-genericScheduler-Preempt-pod-v1-Pod-nodeLister-algorithm-NodeLister-scheduleErr-error" class="headerlink" title="func (g *genericScheduler) Preempt(pod *v1.Pod, nodeLister algorithm.NodeLister, scheduleErr error)"></a><code>func (g *genericScheduler) Preempt(pod *v1.Pod, nodeLister algorithm.NodeLister, scheduleErr error)</code></h2><p><a href="https://github.com/kubernetes/kubernetes/blob/v1.11.7/pkg/scheduler/core/generic_scheduler.go#L209" target="_blank" rel="noopener"><code>kubernetes/pkg/scheduler/core/generic_scheduler.go</code></a><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// preempt finds nodes with pods that can be preempted to make room for "pod" to</span></span><br><span class="line"><span class="comment">// schedule. It chooses one of the nodes and preempts the pods on the node and</span></span><br><span class="line"><span class="comment">// returns 1) the node, 2) the list of preempted pods if such a node is found,</span></span><br><span class="line"><span class="comment">// 3) A list of pods whose nominated node name should be cleared, and 4) any</span></span><br><span class="line"><span class="comment">// possible error.</span></span><br><span class="line"><span class="comment">// Preempt does not update its snapshot. It uses the same snapshot used in the</span></span><br><span class="line"><span class="comment">// scheduling cycle. This is to avoid a scenario where preempt finds feasible</span></span><br><span class="line"><span class="comment">// nodes without preempting any pod. When there are many pending pods in the</span></span><br><span class="line"><span class="comment">// scheduling queue a nominated pod will go back to the queue and behind</span></span><br><span class="line"><span class="comment">// other pods with the same priority. The nominated pod prevents other pods from</span></span><br><span class="line"><span class="comment">// using the nominated resources and the nominated pod could take a long time</span></span><br><span class="line"><span class="comment">// before it is retried after many other pending pods.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *genericScheduler)</span> <span class="title">Preempt</span><span class="params">(pod *v1.Pod, nodeLister algorithm.NodeLister, scheduleErr error)</span> <span class="params">(*v1.Node, []*v1.Pod, []*v1.Pod, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Scheduler may return various types of errors. Consider preemption only if</span></span><br><span class="line">    <span class="comment">// the error is of type FitError.</span></span><br><span class="line">    fitError, ok := scheduleErr.(*FitError)</span><br><span class="line">    <span class="keyword">if</span> !ok || fitError == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !podEligibleToPreemptOthers(pod, g.cachedNodeInfoMap) &#123;</span><br><span class="line">        glog.V(<span class="number">5</span>).Infof(<span class="string">"Pod %v is not eligible for more preemption."</span>, pod.Name)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    allNodes, err := nodeLister.List()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(allNodes) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, ErrNoNodesAvailable</span><br><span class="line">    &#125;</span><br><span class="line">    potentialNodes := nodesWherePreemptionMightHelp(pod, allNodes, fitError.FailedPredicates)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(potentialNodes) == <span class="number">0</span> &#123;</span><br><span class="line">        glog.V(<span class="number">3</span>).Infof(<span class="string">"Preemption will not help schedule pod %v on any node."</span>, pod.Name)</span><br><span class="line">        <span class="comment">// In this case, we should clean-up any existing nominated node name of the pod.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, []*v1.Pod&#123;pod&#125;, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    pdbs, err := g.cache.ListPDBs(labels.Everything())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    nodeToVictims, err := selectNodesForPreemption(pod, g.cachedNodeInfoMap, potentialNodes, g.predicates,</span><br><span class="line">        g.predicateMetaProducer, g.schedulingQueue, pdbs)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We will only check nodeToVictims with extenders that support preemption.</span></span><br><span class="line">    <span class="comment">// Extenders which do not support preemption may later prevent preemptor from being scheduled on the nominated</span></span><br><span class="line">    <span class="comment">// node. In that case, scheduler will find a different host for the preemptor in subsequent scheduling cycles.</span></span><br><span class="line">    nodeToVictims, err = g.processPreemptionWithExtenders(pod, nodeToVictims)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    candidateNode := pickOneNodeForPreemption(nodeToVictims)</span><br><span class="line">    <span class="keyword">if</span> candidateNode == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lower priority pods nominated to run on this node, may no longer fit on</span></span><br><span class="line">    <span class="comment">// this node. So, we should remove their nomination. Removing their</span></span><br><span class="line">    <span class="comment">// nomination updates these pods and moves them to the active queue. It</span></span><br><span class="line">    <span class="comment">// lets scheduler find another place for them.</span></span><br><span class="line">    nominatedPods := g.getLowerPriorityNominatedPods(pod, candidateNode.Name)</span><br><span class="line">    <span class="keyword">if</span> nodeInfo, ok := g.cachedNodeInfoMap[candidateNode.Name]; ok &#123;</span><br><span class="line">        <span class="keyword">return</span> nodeInfo.Node(), nodeToVictims[candidateNode].Pods, nominatedPods, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(</span><br><span class="line">        <span class="string">"preemption failed: the target node %s has been deleted from scheduler cache"</span>,</span><br><span class="line">        candidateNode.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Preempt</code>负责选出优先调度的node和要删除的pod：</p>
<ul>
<li>检查调度的错误是否是预选策略失败的error</li>
<li>检查cachedNodeInfoMap是否有比将要执行优先调度pod的Priority更小的pod再删除</li>
<li>获取所有的node list</li>
<li>检查调度失败的原因是否可以通过抢占其他pod修复</li>
<li>获取pdb list</li>
<li>选出通过抢占其他pod可以成功优先调度pod的node</li>
<li>如果有配置优先调度extender，则再执行优先调度extender筛选上一步的node</li>
<li>从上面步骤筛选出的node中，选出一个最优的node来做优先调度</li>
<li>取得候选node上所有比优先调度pod更低Priority的pods</li>
</ul>
<h2 id="func-nodesWherePreemptionMightHelp-pod-v1-Pod-nodes-v1-Node-failedPredicatesMap-FailedPredicateMap"><a href="#func-nodesWherePreemptionMightHelp-pod-v1-Pod-nodes-v1-Node-failedPredicatesMap-FailedPredicateMap" class="headerlink" title="func nodesWherePreemptionMightHelp(pod *v1.Pod, nodes []*v1.Node, failedPredicatesMap FailedPredicateMap)"></a><code>func nodesWherePreemptionMightHelp(pod *v1.Pod, nodes []*v1.Node, failedPredicatesMap FailedPredicateMap)</code></h2><p><a href="https://github.com/kubernetes/kubernetes/blob/v1.11.7/pkg/scheduler/core/generic_scheduler.go#L980" target="_blank" rel="noopener"><code>kubernetes/pkg/scheduler/core/generic_scheduler.go</code></a><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nodesWherePreemptionMightHelp returns a list of nodes with failed predicates</span></span><br><span class="line"><span class="comment">// that may be satisfied by removing pods from the node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nodesWherePreemptionMightHelp</span><span class="params">(pod *v1.Pod, nodes []*v1.Node, failedPredicatesMap FailedPredicateMap)</span> []*<span class="title">v1</span>.<span class="title">Node</span></span> &#123;</span><br><span class="line">    potentialNodes := []*v1.Node&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, node := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">        unresolvableReasonExist := <span class="literal">false</span></span><br><span class="line">        failedPredicates, _ := failedPredicatesMap[node.Name]</span><br><span class="line">        <span class="comment">// If we assume that scheduler looks at all nodes and populates the failedPredicateMap</span></span><br><span class="line">        <span class="comment">// (which is the case today), the !found case should never happen, but we'd prefer</span></span><br><span class="line">        <span class="comment">// to rely less on such assumptions in the code when checking does not impose</span></span><br><span class="line">        <span class="comment">// significant overhead.</span></span><br><span class="line">        <span class="comment">// Also, we currently assume all failures returned by extender as resolvable.</span></span><br><span class="line">        <span class="keyword">for</span> _, failedPredicate := <span class="keyword">range</span> failedPredicates &#123;</span><br><span class="line">            <span class="keyword">switch</span> failedPredicate &#123;</span><br><span class="line">            <span class="keyword">case</span></span><br><span class="line">                predicates.ErrNodeSelectorNotMatch,</span><br><span class="line">                predicates.ErrPodNotMatchHostName,</span><br><span class="line">                predicates.ErrTaintsTolerationsNotMatch,</span><br><span class="line">                predicates.ErrNodeLabelPresenceViolated,</span><br><span class="line">                predicates.ErrNodeNotReady,</span><br><span class="line">                predicates.ErrNodeNetworkUnavailable,</span><br><span class="line">                predicates.ErrNodeUnschedulable,</span><br><span class="line">                predicates.ErrNodeUnknownCondition,</span><br><span class="line">                predicates.ErrVolumeZoneConflict,</span><br><span class="line">                predicates.ErrVolumeNodeConflict,</span><br><span class="line">                predicates.ErrVolumeBindConflict:</span><br><span class="line">                unresolvableReasonExist = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                <span class="comment">// TODO(bsalamat): Please add affinity failure cases once we have specific affinity failure errors.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !unresolvableReasonExist &#123;</span><br><span class="line">            glog.V(<span class="number">3</span>).Infof(<span class="string">"Node %v is a potential node for preemption."</span>, node.Name)</span><br><span class="line">            potentialNodes = <span class="built_in">append</span>(potentialNodes, node)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> potentialNodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>nodesWherePreemptionMightHelp</code>函数筛选出potentialNodes，逻辑如下：<br>遍历所有的nodes，对每个nodes在sched.schedule()的预选阶段失败的Predicate策略进行扫描，如果failedPredicates包含以下Policy，则说明该node不适合作为Preempt的备选节点</p>
<ul>
<li>predicates.ErrNodeSelectorNotMatch</li>
<li>predicates.ErrPodNotMatchHostName</li>
<li>predicates.ErrTaintsTolerationsNotMatch</li>
<li>predicates.ErrNodeLabelPresenceViolated</li>
<li>predicates.ErrNodeNotReady</li>
<li>predicates.ErrNodeNetworkUnavailable</li>
<li>predicates.ErrNodeUnschedulable</li>
<li>predicates.ErrNodeUnknownCondition</li>
<li>predicates.ErrVolumeZoneConflict</li>
<li>predicates.ErrVolumeNodeConflict</li>
<li>predicates.ErrVolumeBindConflict</li>
</ul>
<h2 id="func-selectNodesForPreemption-……"><a href="#func-selectNodesForPreemption-……" class="headerlink" title="func selectNodesForPreemption(……)"></a><code>func selectNodesForPreemption(……)</code></h2><p><a href="https://github.com/kubernetes/kubernetes/blob/v1.11.7/pkg/scheduler/core/generic_scheduler.go#L815" target="_blank" rel="noopener"><code>kubernetes/pkg/scheduler/core/generic_scheduler.go</code></a><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// selectNodesForPreemption finds all the nodes with possible victims for</span></span><br><span class="line"><span class="comment">// preemption in parallel.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectNodesForPreemption</span><span class="params">(pod *v1.Pod,</span></span></span><br><span class="line"><span class="function"><span class="params">    nodeNameToInfo <span class="keyword">map</span>[<span class="keyword">string</span>]*schedulercache.NodeInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">    potentialNodes []*v1.Node,</span></span></span><br><span class="line"><span class="function"><span class="params">    predicates <span class="keyword">map</span>[<span class="keyword">string</span>]algorithm.FitPredicate,</span></span></span><br><span class="line"><span class="function"><span class="params">    metadataProducer algorithm.PredicateMetadataProducer,</span></span></span><br><span class="line"><span class="function"><span class="params">    queue SchedulingQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    pdbs []*policy.PodDisruptionBudget,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(<span class="keyword">map</span>[*v1.Node]*schedulerapi.Victims, error)</span></span> &#123;</span><br><span class="line">    nodeToVictims := <span class="keyword">map</span>[*v1.Node]*schedulerapi.Victims&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> resultLock sync.Mutex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We can use the same metadata producer for all nodes.</span></span><br><span class="line">    meta := metadataProducer(pod, nodeNameToInfo)</span><br><span class="line">    checkNode := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        nodeName := potentialNodes[i].Name</span><br><span class="line">        <span class="keyword">var</span> metaCopy algorithm.PredicateMetadata</span><br><span class="line">        <span class="keyword">if</span> meta != <span class="literal">nil</span> &#123;</span><br><span class="line">            metaCopy = meta.ShallowCopy()</span><br><span class="line">        &#125;</span><br><span class="line">        pods, numPDBViolations, fits := selectVictimsOnNode(pod, metaCopy, nodeNameToInfo[nodeName], predicates, queue, pdbs)</span><br><span class="line">        <span class="keyword">if</span> fits &#123;</span><br><span class="line">            resultLock.Lock()</span><br><span class="line">            victims := schedulerapi.Victims&#123;</span><br><span class="line">                Pods:             pods,</span><br><span class="line">                NumPDBViolations: numPDBViolations,</span><br><span class="line">            &#125;</span><br><span class="line">            nodeToVictims[potentialNodes[i]] = &amp;victims</span><br><span class="line">            resultLock.Unlock()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    workqueue.Parallelize(<span class="number">16</span>, <span class="built_in">len</span>(potentialNodes), checkNode)</span><br><span class="line">    <span class="keyword">return</span> nodeToVictims, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>selectNodesForPreemption</code>是根据node的数量，启动go routine worker执行<code>selectVictimsOnNode</code>选出node</p>
<h2 id="func-selectVictimsOnNode-……"><a href="#func-selectVictimsOnNode-……" class="headerlink" title="func selectVictimsOnNode(……)"></a><code>func selectVictimsOnNode(……)</code></h2><p><a href="https://github.com/kubernetes/kubernetes/blob/v1.11.7/pkg/scheduler/core/generic_scheduler.go#L903" target="_blank" rel="noopener"><code>kubernetes/pkg/scheduler/core/generic_scheduler.go</code></a><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// selectVictimsOnNode finds minimum set of pods on the given node that should</span></span><br><span class="line"><span class="comment">// be preempted in order to make enough room for "pod" to be scheduled. The</span></span><br><span class="line"><span class="comment">// minimum set selected is subject to the constraint that a higher-priority pod</span></span><br><span class="line"><span class="comment">// is never preempted when a lower-priority pod could be (higher/lower relative</span></span><br><span class="line"><span class="comment">// to one another, not relative to the preemptor "pod").</span></span><br><span class="line"><span class="comment">// The algorithm first checks if the pod can be scheduled on the node when all the</span></span><br><span class="line"><span class="comment">// lower priority pods are gone. If so, it sorts all the lower priority pods by</span></span><br><span class="line"><span class="comment">// their priority and then puts them into two groups of those whose PodDisruptionBudget</span></span><br><span class="line"><span class="comment">// will be violated if preempted and other non-violating pods. Both groups are</span></span><br><span class="line"><span class="comment">// sorted by priority. It first tries to reprieve as many PDB violating pods as</span></span><br><span class="line"><span class="comment">// possible and then does them same for non-PDB-violating pods while checking</span></span><br><span class="line"><span class="comment">// that the "pod" can still fit on the node.</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> This function assumes that it is never called if "pod" cannot be scheduled</span></span><br><span class="line"><span class="comment">// due to pod affinity, node affinity, or node anti-affinity reasons. None of</span></span><br><span class="line"><span class="comment">// these predicates can be satisfied by removing more pods from the node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectVictimsOnNode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    pod *v1.Pod,</span></span></span><br><span class="line"><span class="function"><span class="params">    meta algorithm.PredicateMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">    nodeInfo *schedulercache.NodeInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">    fitPredicates <span class="keyword">map</span>[<span class="keyword">string</span>]algorithm.FitPredicate,</span></span></span><br><span class="line"><span class="function"><span class="params">    queue SchedulingQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    pdbs []*policy.PodDisruptionBudget,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">([]*v1.Pod, <span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> nodeInfo == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    potentialVictims := util.SortableList&#123;CompFunc: util.HigherPriorityPod&#125;</span><br><span class="line">    nodeInfoCopy := nodeInfo.Clone()</span><br><span class="line"></span><br><span class="line">    removePod := <span class="function"><span class="keyword">func</span><span class="params">(rp *v1.Pod)</span></span> &#123;</span><br><span class="line">        nodeInfoCopy.RemovePod(rp)</span><br><span class="line">        <span class="keyword">if</span> meta != <span class="literal">nil</span> &#123;</span><br><span class="line">            meta.RemovePod(rp)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addPod := <span class="function"><span class="keyword">func</span><span class="params">(ap *v1.Pod)</span></span> &#123;</span><br><span class="line">        nodeInfoCopy.AddPod(ap)</span><br><span class="line">        <span class="keyword">if</span> meta != <span class="literal">nil</span> &#123;</span><br><span class="line">            meta.AddPod(ap, nodeInfoCopy)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// As the first step, remove all the lower priority pods from the node and</span></span><br><span class="line">    <span class="comment">// check if the given pod can be scheduled.</span></span><br><span class="line">    podPriority := util.GetPodPriority(pod)</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> nodeInfoCopy.Pods() &#123;</span><br><span class="line">        <span class="keyword">if</span> util.GetPodPriority(p) &lt; podPriority &#123;</span><br><span class="line">            potentialVictims.Items = <span class="built_in">append</span>(potentialVictims.Items, p)</span><br><span class="line">            removePod(p)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    potentialVictims.Sort()</span><br><span class="line">    <span class="comment">// If the new pod does not fit after removing all the lower priority pods,</span></span><br><span class="line">    <span class="comment">// we are almost done and this node is not suitable for preemption. The only condition</span></span><br><span class="line">    <span class="comment">// that we should check is if the "pod" is failing to schedule due to pod affinity</span></span><br><span class="line">    <span class="comment">// failure.</span></span><br><span class="line">    <span class="comment">// TODO(bsalamat): Consider checking affinity to lower priority pods if feasible with reasonable performance.</span></span><br><span class="line">    <span class="keyword">if</span> fits, _, err := podFitsOnNode(pod, meta, nodeInfoCopy, fitPredicates, <span class="literal">nil</span>, <span class="literal">nil</span>, queue, <span class="literal">false</span>, <span class="literal">nil</span>); !fits &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            glog.Warningf(<span class="string">"Encountered error while selecting victims on node %v: %v"</span>, nodeInfo.Node().Name, err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> victims []*v1.Pod</span><br><span class="line">    numViolatingVictim := <span class="number">0</span></span><br><span class="line">    <span class="comment">// Try to reprieve as many pods as possible. We first try to reprieve the PDB</span></span><br><span class="line">    <span class="comment">// violating victims and then other non-violating ones. In both cases, we start</span></span><br><span class="line">    <span class="comment">// from the highest priority victims.</span></span><br><span class="line">    violatingVictims, nonViolatingVictims := filterPodsWithPDBViolation(potentialVictims.Items, pdbs)</span><br><span class="line">    reprievePod := <span class="function"><span class="keyword">func</span><span class="params">(p *v1.Pod)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        addPod(p)</span><br><span class="line">        fits, _, _ := podFitsOnNode(pod, meta, nodeInfoCopy, fitPredicates, <span class="literal">nil</span>, <span class="literal">nil</span>, queue, <span class="literal">false</span>, <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">if</span> !fits &#123;</span><br><span class="line">            removePod(p)</span><br><span class="line">            victims = <span class="built_in">append</span>(victims, p)</span><br><span class="line">            glog.V(<span class="number">5</span>).Infof(<span class="string">"Pod %v is a potential preemption victim on node %v."</span>, p.Name, nodeInfo.Node().Name)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fits</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> violatingVictims &#123;</span><br><span class="line">        <span class="keyword">if</span> !reprievePod(p) &#123;</span><br><span class="line">            numViolatingVictim++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Now we try to reprieve non-violating victims.</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> nonViolatingVictims &#123;</span><br><span class="line">        reprievePod(p)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> victims, numViolatingVictim, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>selectVictimsOnNode</code>选出node给进行优先调度的pod腾出资源需要删除的pod，以及对删除pod而导致pod少于pdb定义进行技术，流程如下：</p>
<ul>
<li>获取优先调度pod的PodPriority</li>
<li>获取所有比优先调度pod的PodPriority更小的pod，并执行removePod函数删除这些pod</li>
<li>在上一步删除Pod之后，再在node上对优先调度pod进行预选</li>
<li>对前面删除pod，检查是否会导致pod的数量小于pdb的min-available</li>
<li>先对因为pdb限制不能删除的pod执行reprievePod函数（先addPod再执行预选，如果预选失败则removePod）</li>
<li>再对没有pdb限制或者pdb允许删除的pod执行reprievePod函数</li>
</ul>
<h2 id="func-pickOneNodeForPreemption-nodesToVictims-map-v1-Node-schedulerapi-Victims"><a href="#func-pickOneNodeForPreemption-nodesToVictims-map-v1-Node-schedulerapi-Victims" class="headerlink" title="func pickOneNodeForPreemption(nodesToVictims map[*v1.Node]*schedulerapi.Victims)"></a><code>func pickOneNodeForPreemption(nodesToVictims map[*v1.Node]*schedulerapi.Victims)</code></h2><p><a href="https://github.com/kubernetes/kubernetes/blob/v1.11.7/pkg/scheduler/core/generic_scheduler.go#L708" target="_blank" rel="noopener"><code>kubernetes/pkg/scheduler/core/generic_scheduler.go</code></a><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pickOneNodeForPreemption chooses one node among the given nodes. It assumes</span></span><br><span class="line"><span class="comment">// pods in each map entry are ordered by decreasing priority.</span></span><br><span class="line"><span class="comment">// It picks a node based on the following criteria:</span></span><br><span class="line"><span class="comment">// 1. A node with minimum number of PDB violations.</span></span><br><span class="line"><span class="comment">// 2. A node with minimum highest priority victim is picked.</span></span><br><span class="line"><span class="comment">// 3. Ties are broken by sum of priorities of all victims.</span></span><br><span class="line"><span class="comment">// 4. If there are still ties, node with the minimum number of victims is picked.</span></span><br><span class="line"><span class="comment">// 5. If there are still ties, the first such node is picked (sort of randomly).</span></span><br><span class="line"><span class="comment">// The 'minNodes1' and 'minNodes2' are being reused here to save the memory</span></span><br><span class="line"><span class="comment">// allocation and garbage collection time.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pickOneNodeForPreemption</span><span class="params">(nodesToVictims <span class="keyword">map</span>[*v1.Node]*schedulerapi.Victims)</span> *<span class="title">v1</span>.<span class="title">Node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nodesToVictims) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    minNumPDBViolatingPods := math.MaxInt32</span><br><span class="line">    <span class="keyword">var</span> minNodes1 []*v1.Node</span><br><span class="line">    lenNodes1 := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> node, victims := <span class="keyword">range</span> nodesToVictims &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(victims.Pods) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// We found a node that doesn't need any preemption. Return it!</span></span><br><span class="line">            <span class="comment">// This should happen rarely when one or more pods are terminated between</span></span><br><span class="line">            <span class="comment">// the time that scheduler tries to schedule the pod and the time that</span></span><br><span class="line">            <span class="comment">// preemption logic tries to find nodes for preemption.</span></span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        &#125;</span><br><span class="line">        numPDBViolatingPods := victims.NumPDBViolations</span><br><span class="line">        <span class="keyword">if</span> numPDBViolatingPods &lt; minNumPDBViolatingPods &#123;</span><br><span class="line">            minNumPDBViolatingPods = numPDBViolatingPods</span><br><span class="line">            minNodes1 = <span class="literal">nil</span></span><br><span class="line">            lenNodes1 = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> numPDBViolatingPods == minNumPDBViolatingPods &#123;</span><br><span class="line">            minNodes1 = <span class="built_in">append</span>(minNodes1, node)</span><br><span class="line">            lenNodes1++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> lenNodes1 == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minNodes1[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// There are more than one node with minimum number PDB violating pods. Find</span></span><br><span class="line">    <span class="comment">// the one with minimum highest priority victim.</span></span><br><span class="line">    minHighestPriority := <span class="keyword">int32</span>(math.MaxInt32)</span><br><span class="line">    <span class="keyword">var</span> minNodes2 = <span class="built_in">make</span>([]*v1.Node, lenNodes1)</span><br><span class="line">    lenNodes2 := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; lenNodes1; i++ &#123;</span><br><span class="line">        node := minNodes1[i]</span><br><span class="line">        victims := nodesToVictims[node]</span><br><span class="line">        <span class="comment">// highestPodPriority is the highest priority among the victims on this node.</span></span><br><span class="line">        highestPodPriority := util.GetPodPriority(victims.Pods[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> highestPodPriority &lt; minHighestPriority &#123;</span><br><span class="line">            minHighestPriority = highestPodPriority</span><br><span class="line">            lenNodes2 = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> highestPodPriority == minHighestPriority &#123;</span><br><span class="line">            minNodes2[lenNodes2] = node</span><br><span class="line">            lenNodes2++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> lenNodes2 == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minNodes2[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// There are a few nodes with minimum highest priority victim. Find the</span></span><br><span class="line">    <span class="comment">// smallest sum of priorities.</span></span><br><span class="line">    minSumPriorities := <span class="keyword">int64</span>(math.MaxInt64)</span><br><span class="line">    lenNodes1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; lenNodes2; i++ &#123;</span><br><span class="line">        <span class="keyword">var</span> sumPriorities <span class="keyword">int64</span></span><br><span class="line">        node := minNodes2[i]</span><br><span class="line">        <span class="keyword">for</span> _, pod := <span class="keyword">range</span> nodesToVictims[node].Pods &#123;</span><br><span class="line">            <span class="comment">// We add MaxInt32+1 to all priorities to make all of them &gt;= 0. This is</span></span><br><span class="line">            <span class="comment">// needed so that a node with a few pods with negative priority is not</span></span><br><span class="line">            <span class="comment">// picked over a node with a smaller number of pods with the same negative</span></span><br><span class="line">            <span class="comment">// priority (and similar scenarios).</span></span><br><span class="line">            sumPriorities += <span class="keyword">int64</span>(util.GetPodPriority(pod)) + <span class="keyword">int64</span>(math.MaxInt32+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sumPriorities &lt; minSumPriorities &#123;</span><br><span class="line">            minSumPriorities = sumPriorities</span><br><span class="line">            lenNodes1 = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sumPriorities == minSumPriorities &#123;</span><br><span class="line">            minNodes1[lenNodes1] = node</span><br><span class="line">            lenNodes1++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> lenNodes1 == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minNodes1[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// There are a few nodes with minimum highest priority victim and sum of priorities.</span></span><br><span class="line">    <span class="comment">// Find one with the minimum number of pods.</span></span><br><span class="line">    minNumPods := math.MaxInt32</span><br><span class="line">    lenNodes2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; lenNodes1; i++ &#123;</span><br><span class="line">        node := minNodes1[i]</span><br><span class="line">        numPods := <span class="built_in">len</span>(nodesToVictims[node].Pods)</span><br><span class="line">        <span class="keyword">if</span> numPods &lt; minNumPods &#123;</span><br><span class="line">            minNumPods = numPods</span><br><span class="line">            lenNodes2 = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> numPods == minNumPods &#123;</span><br><span class="line">            minNodes2[lenNodes2] = node</span><br><span class="line">            lenNodes2++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// At this point, even if there are more than one node with the same score,</span></span><br><span class="line">    <span class="comment">// return the first one.</span></span><br><span class="line">    <span class="keyword">if</span> lenNodes2 &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minNodes2[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    glog.Errorf(<span class="string">"Error in logic of node scoring for preemption. We should never reach here!"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>pickOneNodeForPreemption</code>从可以进行优先调度的node中选出最优的一个node：</p>
<ul>
<li>如果node不用preemption pod，直接返回</li>
<li>选出对pdb影响最小的node，如果只有一个node，直接返回</li>
<li>选择victims中最高PodPriority中最低的node，如果只有一个node，直接返回</li>
<li>选择所有victims优先级最小的node，如果只有一个node，直接返回</li>
<li>选择victims pod数最少的node，如果只有一个node，直接返回</li>
<li>如果上一步有不止一个node满足，随机选择一个node返回</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2019/02/25/Kubernetes源码阅读—kubectl(一)/" class="next">NEXT</a></div><div class="copyright"><p>© 2018 - 2019 <a href="http://xizie.com">Bin Xu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>